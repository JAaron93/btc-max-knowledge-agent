#!/usr/bin/env python3
"""
Deterministic admin password hashing utilities for tests.

This is the canonical implementation used by tests. Other locations may import
this module directly or via thin forwarders to avoid duplicating logic.
"""

from __future__ import annotations

import hashlib
import hmac
import os
from typing import Tuple


_DEFAULT_ITERATIONS: int = 100_000
_DEFAULT_DIGEST: str = "sha256"
_ENV_SALT_KEY: str = "TEST_ADMIN_HASH_SALT"


def _get_salt() -> bytes:
    """
    Get deterministic salt from environment for reproducible tests.

    Falls back to a constant development-only salt to ensure stability when the
    environment variable is not set (e.g., CI or local runs without explicit config).
    """
    salt = os.getenv(_ENV_SALT_KEY)
    if salt is None:
        # Development-only fallback salt; safe for tests
        salt = "dev-static-salt-for-tests"
    return salt.encode("utf-8")


def _pbkdf_like(key: bytes, salt: bytes, iterations: int, digest: str) -> bytes:
    """
    PBKDF2-like deterministic derivation using HMAC in a loop.

    Not intended as a production-ready KDF. This is designed for testing where
    deterministic outputs are required across environments.
    """
    try:
        digestmod = getattr(hashlib, digest)
    except AttributeError as exc:
        raise ValueError(f"Unsupported digest algorithm: {digest}") from exc

    result = b""
    block = salt
    for _ in range(iterations):
        block = hmac.new(key, block, digestmod).digest()
        result = hmac.new(key, result + block, digestmod).digest()
    return result


def hash_password(
    password: str,
    iterations: int = _DEFAULT_ITERATIONS,
    digest: str = _DEFAULT_DIGEST,
) -> str:
    """
    Create a deterministic hash for the provided password.

    Returns hex string containing algorithm metadata for verification.
    Format: algo:digest:iterations:hex
    """
    if not isinstance(password, str) or password == "":
        raise ValueError("password must be a non-empty string")

    salt = _get_salt()
    key = password.encode("utf-8")
    derived = _pbkdf_like(key, salt, iterations, digest)
    return f"alg:hmac-{digest}:iter:{iterations}:val:{derived.hex()}"


def verify_password(
    password: str,
    hashed: str,
) -> bool:
    """
    Verify a password against a deterministic hashed string generated by hash_password.
    """
    if not hashed or not isinstance(hashed, str):
        return False
    try:
        parts = hashed.split(":")
        # Expected parts: ["alg", "hmac-digest", "iter", "iterations", "val", "hex"]
        algo = parts[1]  # e.g., "hmac-sha256"
        iterations = int(parts[3])
        digest = algo.split("-", 1)[1]
        recomputed = hash_password(password, iterations=iterations, digest=digest)
        return hmac.compare_digest(hashed, recomputed)
    except Exception:
        return False


if __name__ == "__main__":
    # Simple manual test utility
    import sys

    if len(sys.argv) < 3:
        print("Usage: generate_admin_hash.py <hash|verify> <password> [hash]")
        sys.exit(1)

    command = sys.argv[1]
    if command == "hash":
        print(hash_password(sys.argv[2]))
    elif command == "verify":
        if len(sys.argv) < 4:
            print("Missing hash to verify against")
            sys.exit(2)
        print("OK" if verify_password(sys.argv[2], sys.argv[3]) else "FAIL")
    else:
        print(f"Unknown command: {command}")
        sys.exit(3)